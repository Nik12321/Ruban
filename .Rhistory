if (flag == TRUE)
break
}
cat("Сделано шагов: ", k, "\n")
return(allX[which.min(allResults), ])
}
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
Ruban <- function(x,
deltaX,
f,
lower,
upper,
n = 500,
e = 0.001,
M = 1000,
y = 1,
q = 2,
nuclear_function = 1,
r = 2,
s = 100) {
if (length(x) != length(deltaX)
|| length(x) != length(lower)
|| length(x) != length(upper)) {
stop("Error")
}
if (n < 0)
stop("Error")
if (e < 0)
stop("Error")
if (M < 0)
stop("Error")
if (y < 0)
stop("Error")
k <- 1
testX <- matrix(0, n, length(x))
functionValues <- rep(0, n)
uValues <- matrix(0, n, length(x))
p <- rep(0, n)
pNorm <- rep(0, n)
allX <- matrix(0, M, length(x))
allX[1, ] <- x
allResults <- f(x)
while (k < M) {
for (i in 1:n) {
for (j in 1:length(x))
uValues[i, j] <- runif(1, 0, 1) * 2 - 1
testX[i, ] <- x + deltaX * uValues[i, ]
functionValues[i] <- f(testX[i,])
}
gmin <- rep(0, n)
for (i in 1:n) {
a <- functionValues[i] - min(functionValues)
b <- max(functionValues) - min(functionValues)
gmin[i] <- a / b
}
for (i in 1:n)
p[i] <- nuclearFunction(x = nuclear_function, z = gmin[i], r = r, s = s)
for (i in 1:n)
pNorm[i] <- p[i] / sum(p)
for (i in 1:length(x))
x[i] <- x[i] + deltaX[i] * sum(sapply(1:n, function(x) {
uValues[x, i] * pNorm[x]
}))
if (x[1] < lower[1])
x[1] <- lower[1]
if (x[2] < lower[2])
x[2] <- lower[2]
if (x[1] > upper[1])
x[1] <- upper[1]
if (x[2] > upper[2])
x[2] <- upper[2]
print("---------------")
cat("Результат ", k, "итерации: x=", x,"\n")
for (i in 1:length(x))
deltaX[i] <- y * deltaX[i] * ( (sum(sapply(1:n, function(x) {
(abs(uValues[x, i]) ^ (q)) * pNorm[x]
}
))) ^ (1 / q))
k <- k + 1
allX[k, ] <- x
allResults <- c(allResults, f(x))
cat("deltaX=", deltaX, "\n")
flag <- (max(deltaX) <= e)
if (flag == TRUE)
break
}
cat("Сделано шагов: ", k, "\n")
return(allX[which.min(allResults), ])
}
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
Ruban <- function(x,
deltaX,
f,
lower,
upper,
n = 500,
e = 0.001,
M = 1000,
y = 1,
q = 2,
nuclear_function = 1,
r = 2,
s = 100) {
if (length(x) != length(deltaX)
|| length(x) != length(lower)
|| length(x) != length(upper)) {
stop("Error")
}
if (n < 0)
stop("Error")
if (e < 0)
stop("Error")
if (M < 0)
stop("Error")
if (y < 0)
stop("Error")
k <- 1
testX <- matrix(0, n, length(x))
functionValues <- rep(0, n)
uValues <- matrix(0, n, length(x))
p <- rep(0, n)
pNorm <- rep(0, n)
allX <- matrix(0, M, length(x))
allX[1, ] <- x
allResults <- f(x)
while (k < M) {
for (i in 1:n) {
for (j in 1:length(x))
uValues[i, j] <- runif(1, 0, 1) * 2 - 1
testX[i, ] <- x + deltaX * uValues[i, ]
functionValues[i] <- f(testX[i,])
}
gmin <- rep(0, n)
for (i in 1:n) {
a <- functionValues[i] - min(functionValues)
b <- max(functionValues) - min(functionValues)
gmin[i] <- a / b
}
for (i in 1:n)
p[i] <- nuclearFunction(x = nuclear_function, z = gmin[i], r = r, s = s)
for (i in 1:n)
pNorm[i] <- p[i] / sum(p)
for (i in 1:length(x))
x[i] <- x[i] + deltaX[i] * sum(sapply(1:n, function(x) {
uValues[x, i] * pNorm[x]
}))
if (x[1] < lower[1])
x[1] <- lower[1]
if (x[2] < lower[2])
x[2] <- lower[2]
if (x[1] > upper[1])
x[1] <- upper[1]
if (x[2] > upper[2])
x[2] <- upper[2]
print("---------------")
cat("Результат ", k, "итерации: x=", x,"\n")
for (i in 1:length(x))
deltaX[i] <- y * deltaX[i] * ( (sum(sapply(1:n, function(x) {
(abs(uValues[x, i]) ^ (q)) * pNorm[x]
}
))) ^ (1 / q))
k <- k + 1
allX[k, ] <- x
allResults <- c(allResults, f(x))
cat("deltaX=", deltaX, "\n")
flag <- (max(deltaX) <= e)
if (flag == TRUE)
break
}
cat("Сделано шагов: ", k, "\n")
return(allX[which.min(allResults), ])
}
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
Ruban <- function(x,
deltaX,
f,
lower,
upper,
n = 500,
e = 0.001,
M = 1000,
y = 1,
q = 2,
nuclear_function = 1,
r = 2,
s = 100) {
if (length(x) != length(deltaX)
|| length(x) != length(lower)
|| length(x) != length(upper)) {
stop("Error")
}
if (n < 0)
stop("Error")
if (e < 0)
stop("Error")
if (M < 0)
stop("Error")
if (y < 0)
stop("Error")
k <- 1
testX <- matrix(0, n, length(x))
functionValues <- rep(0, n)
uValues <- matrix(0, n, length(x))
p <- rep(0, n)
pNorm <- rep(0, n)
allX <- matrix(0, M, length(x))
allX[1, ] <- x
allResults <- f(x)
while (k < M) {
for (i in 1:n) {
for (j in 1:length(x))
uValues[i, j] <- runif(1, 0, 1) * 2 - 1
testX[i, ] <- x + deltaX * uValues[i, ]
functionValues[i] <- f(testX[i,])
}
gmin <- rep(0, n)
for (i in 1:n) {
a <- functionValues[i] - min(functionValues)
b <- max(functionValues) - min(functionValues)
gmin[i] <- a / b
}
for (i in 1:n)
p[i] <- nuclearFunction(x = nuclear_function, z = gmin[i], r = r, s = s)
for (i in 1:n)
pNorm[i] <- p[i] / sum(p)
for (i in 1:length(x))
x[i] <- x[i] + deltaX[i] * sum(sapply(1:n, function(x) {
uValues[x, i] * pNorm[x]
}))
if (x[1] < lower[1])
x[1] <- lower[1]
if (x[2] < lower[2])
x[2] <- lower[2]
if (x[1] > upper[1])
x[1] <- upper[1]
if (x[2] > upper[2])
x[2] <- upper[2]
print("---------------")
cat("Результат ", k, "итерации: x=", x,"\n")
for (i in 1:length(x))
deltaX[i] <- y * deltaX[i] * ( (sum(sapply(1:n, function(x) {
(abs(uValues[x, i]) ^ (q)) * pNorm[x]
}
))) ^ (1 / q))
k <- k + 1
allX[k, ] <- x
allResults <- c(allResults, f(x))
cat("deltaX=", deltaX, "\n")
flag <- (max(deltaX) <= e)
if (flag == TRUE)
break
}
cat("Сделано шагов: ", k, "\n")
return(allX[which.min(allResults), ])
}
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
Ruban <- function(x,
deltaX,
f,
lower,
upper,
n = 500,
e = 0.001,
M = 1000,
y = 1,
q = 2,
nuclear_function = 1,
r = 2,
s = 100) {
if (length(x) != length(deltaX)
|| length(x) != length(lower)
|| length(x) != length(upper)) {
stop("Error")
}
if (n < 0)
stop("Error")
if (e < 0)
stop("Error")
if (M < 0)
stop("Error")
if (y < 0)
stop("Error")
k <- 1
testX <- matrix(0, n, length(x))
functionValues <- rep(0, n)
uValues <- matrix(0, n, length(x))
p <- rep(0, n)
pNorm <- rep(0, n)
allX <- matrix(0, M, length(x))
allX[1, ] <- x
allResults <- f(x)
while (k < M) {
for (i in 1:n) {
for (j in 1:length(x))
uValues[i, j] <- runif(1, 0, 1) * 2 - 1
testX[i, ] <- x + deltaX * uValues[i, ]
functionValues[i] <- f(testX[i,])
}
gmin <- rep(0, n)
for (i in 1:n) {
a <- functionValues[i] - min(functionValues)
b <- max(functionValues) - min(functionValues)
gmin[i] <- a / b
}
for (i in 1:n)
p[i] <- nuclearFunction(x = nuclear_function, z = gmin[i], r = r, s = s)
for (i in 1:n)
pNorm[i] <- p[i] / sum(p)
for (i in 1:length(x))
x[i] <- x[i] + deltaX[i] * sum(sapply(1:n, function(x) {
uValues[x, i] * pNorm[x]
}))
if (x[1] < lower[1])
x[1] <- lower[1]
if (x[2] < lower[2])
x[2] <- lower[2]
if (x[1] > upper[1])
x[1] <- upper[1]
if (x[2] > upper[2])
x[2] <- upper[2]
print("---------------")
cat("Результат ", k, "итерации: x=", x,"\n")
for (i in 1:length(x))
deltaX[i] <- y * deltaX[i] * ( (sum(sapply(1:n, function(x) {
(abs(uValues[x, i]) ^ (q)) * pNorm[x]
}
))) ^ (1 / q))
k <- k + 1
allX[k, ] <- x
allResults <- c(allResults, f(x))
cat("deltaX=", deltaX, "\n")
flag <- (max(deltaX) <= e)
if (flag == TRUE)
break
}
cat("Сделано шагов: ", k, "\n")
return(allX[which.min(allResults), ])
}
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, nuclear_function = 1)
print(x)
##Ядерные функции. По умолчанию используется первая.
nuclearFunction<-function(z, x = 1, r = 2, s = 3) {
if (x == 1) {
p<-(1-(z^r))^s
}
else if (x == 2) {
p<-exp(-s*(z^r))
}
else if (x == 3) {
p<-1/(s*(z^r)+1)
}
else if (x == 4) {
p<-1/(z^s)
}
else
p <- 0
return(p)
}
f<- function(x, y)
{
z<-function(x)
return(-(1/((x-1)^2 + 0.2))-(1/(2*(x-2)^2 + 0.15)) -(1/(3*(x-3)^2 + 0.3)))
return(z(x)+z(y))
}
Ruban <- function(x, deltaX, f, lower, upper, n = 500, e = 0.001, M = 1000, y = 1, q = 2, numberOfNuclearFunc = 1, r = 2, s = 100) {
if (length(x)!= length(deltaX) || length(x)!= length(lower)  || length(x)!= length(upper))
stop("Ошибка, не соблюдение размерности у входящих параметров (x, deltaX, upper, lower)!")
if (n<0)
stop("Ошибка, количество пробных точек должно быть больше 0!")
if (e<0)
stop("Ошибка, константа точности не должна быть меньше 0!")
if (M<0)
stop("Ошибка, максимальное количество итераций не должно быть меньше 0!")
if (y<0)
stop("Ошибка, (y) не должен быть меньше 0!")
k<-1 ##Будем использовать для проверки первого критерия останова - превышения числа итераций
testX<-matrix(0, n, length(x)) ## В матрицу будут записываться пробные точки.
## Где n - количество пробных точек,
## length(x) - количество координатых направлений
functionValues<-rep(0, n) ## А эта матрица содержит значения функции в пробных точках
uValues<-matrix(0, n, length(x)) ##В этой матрице будут храниться значения u для генерации пробных точек
p<-rep(0, n) ##Ядра
pNorm<-rep(0, n) ##нормированные ядра
allX<-matrix(0, M, length(x)) ##Сюда записываем все X
allX[1,]<-x
allResults<-f(x[1],x[2]) ##Сюда записываем все результаты. Если число циклов превысит M, то мы выберем из всех результатов наименьший
while(k<M) {
pastIterationX<-x ##Запоминаем текущую точку, мы будем использовать ее для условия выхода
plot(pastIterationX[1], pastIterationX[2], xlim=c(lower[1],upper[1]), ylim=c(lower[2],upper[2]), col="red")
##Шаг первый - инициализация пробных точек и расчет значений функции в них:
for (i in 1:n) {
for (j in 1:length(x))
uValues[i,j]<-runif(1, 0, 1)*2 - 1 ##Генерируем u от -1 до 1
testX[i,]<- x + deltaX * uValues[i,]  ##Генерируем пробную точку
functionValues[i] <- f(testX[i,1],testX[i,2]) ##Находит значение функции в этой точке(f - какая-то функция)
points(testX[i,1],testX[i,2], col="blue")
}
gmin<-rep(0, n)
##Шаг второй - рассчитываем ядра и нормированные ядра:
for (i in 1:n)
gmin[i]<-(functionValues[i] - min(functionValues)) / (max(functionValues) - min(functionValues))
for(i in 1:n) ##Вычисляем ядра
p[i]<-nuclearFunction(x = numberOfNuclearFunc, z = gmin[i], r=r, s=s)
for (i in 1:n) ##Вычисляем нормированные ядра
pNorm[i]<-p[i]/sum(p)
##Шаг третий - вычисляем новый центр прямоугольника и его длину:
for (i in 1:length(x))
x[i]<-x[i] + deltaX[i] * sum(sapply(1:n, function(x){uValues[x,i]*pNorm[x]}))
print("---------------")
cat("Результат ", k, "итерации: x=", x,"\n")
if (x[1]<lower[1])
x[1]<-lower[1]
if (x[2]<lower[2])
x[2]<-lower[2]
if (x[1]>upper[1])
x[1]<-upper[1]
if (x[2]>upper[2])
x[2]<-upper[2]
for (i in 1:length(x))
deltaX[i]<-y*deltaX[i] * ((sum(sapply(1:n, function(x){(abs(uValues[x,i])^(q)) * pNorm[x]})))^(1/q))
cat("deltaX=", deltaX, "\n")
k<-k+1 ##Увеличиваем счетчик итераций
allX[k,]<-x
allResults<-c(allResults,f(x[1],x[2]))
flag <- (max(deltaX) <= e)
if (flag == TRUE)
break
#if (sqrt(sum(deltaX^2)) < e)
#  break
}
cat("Сделано шагов: ", k, "\n")
return(allX[which.min(allResults),])
}
f<-function(x,y) {
z<-7*(abs(x)^2) + 7*(abs(y)^2)
z<-c(z, 5*(abs(x-3))^0.8 + 5*(abs(y-3)^0.6) + 6)
z<-c(z, 5*(abs(x-6))^1.3 + 5*(abs(y-6)^1.3) + 2)
z<-c(z, 5*(abs(x-6))^1 + 5*(abs(y+6)^1) + 8)
z<-c(z, 4*(abs(x+6))^1.5 + 4*(abs(y+6)^1.5) + 7)
z<-c(z, 5*(abs(x+3))^1.8 + 5*(abs(y)^1.8) + 9)
z<-c(z, 6*(abs(x+6))^0.6 + 6*(abs(y-6)^0.9))
return(min(z))
}
print("Минимум в точке (0;0)")
print(f(0,0))
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, numberOfNuclearFunc = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, numberOfNuclearFunc = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, numberOfNuclearFunc = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, numberOfNuclearFunc = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, numberOfNuclearFunc = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, numberOfNuclearFunc = 1)
print(x)
x<-Ruban(x=c(10,10), deltaX=c(20,20), lower=c(-10,-10), upper = c(30,30), f = f, n=500, y=1, q=2, s=100, e=0.0001, r=2, numberOfNuclearFunc = 1)
print(x)
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
devtools::load_all()
devtools::load_all()
nuclearFunction(1)
nuclearFunction(2)
devtools::check()
factor("a") %>%
expect_type("integer") %>%
expect_s3_class("factor") %>%
expect_length(1)
factor("a") %>%
expect_type("integer") %>%
expect_s3_class("factor") %>%
expect_length(1)
factor("a") 3>5
expect_type("integer") 3>5
expect_s3_class("factor") 1>3
expect_length(1)
factor(а)
factor(2)
factor(4)
factor(5)
factor(100)
install.packages("testthat")
install.packages("testthat")
devtools::check()
nuclearFunction(1)
nuclearFunction(2)
nuclearFunction(3)
nuclearFunction(4)
devtools::test()
devtools::use_testthat()
usethis::use_testthat()
devtools::test()
devtools::check()
